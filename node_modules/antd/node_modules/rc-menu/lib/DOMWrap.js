'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _debounce = require('lodash/debounce');

var _debounce2 = _interopRequireDefault(_debounce);

var _SubMenu = require('./SubMenu');

var _SubMenu2 = _interopRequireDefault(_SubMenu);

var _miniStore = require('mini-store');

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var DOMWrap = function (_React$Component) {
  (0, _inherits3['default'])(DOMWrap, _React$Component);

  function DOMWrap() {
    var _temp, _this, _ret;

    (0, _classCallCheck3['default'])(this, DOMWrap);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      lastVisibleIndex: undefined
    }, _this.getOverflowedSubMenuItem = function () {
      var overflowedIndicator = _this.props.overflowedIndicator;
      // put all the overflowed item inside a submenu
      // with a title of overflow indicator ('...')

      var copy = _this.props.children[0];
      var _copy$props = copy.props,
          throwAway = _copy$props.children,
          title = _copy$props.title,
          eventKey = _copy$props.eventKey,
          rest = (0, _objectWithoutProperties3['default'])(_copy$props, ['children', 'title', 'eventKey']);


      return _react2['default'].createElement(
        _SubMenu2['default'],
        (0, _extends3['default'])({
          title: overflowedIndicator,
          className: _this.props.prefixCls + '-overflowed-submenu'
        }, rest, {
          eventKey: 'overflowed-indicator',
          disabled: false
        }),
        _this.overflowedItems
      );
    }, _this.originalScrollWidth = 0, _this.overflowedItems = [], _this.childrenSizes = [], _this.handleResize = function () {
      if (_this.props.mode !== 'horizontal') {
        return;
      }

      var ul = _reactDom2['default'].findDOMNode(_this);
      var width = (0, _util.getWidth)(ul);

      _this.overflowedItems = [];
      var currentSumWidth = 0;
      var children = _this.props.children;

      // index for last visible child in horizontal mode
      var lastVisibleIndex = undefined;

      if (_this.originalScrollWidth > width) {
        lastVisibleIndex = -1;

        _this.childrenSizes.forEach(function (liWidth) {
          currentSumWidth += liWidth;
          if (currentSumWidth + _this.overflowedIndicatorWidth <= width) {
            lastVisibleIndex++;
          }
        });

        children.slice(lastVisibleIndex + 1).forEach(function (c) {
          // children[index].key will become '.$key' in clone by default,
          // we have to overwrite with the correct key explicitly
          _this.overflowedItems.push(_react2['default'].cloneElement(c, { key: c.props.eventKey, mode: 'vertical-left' }));
        });
      }

      _this.setState({ lastVisibleIndex: lastVisibleIndex });
    }, _this.debouncedHandleResize = (0, _debounce2['default'])(_this.handleResize, 150), _temp), (0, _possibleConstructorReturn3['default'])(_this, _ret);
  }

  DOMWrap.prototype.componentDidMount = function componentDidMount() {
    this.updateNodesCacheAndResize();
    window.addEventListener('resize', this.debouncedHandleResize, { passive: true });
  };

  DOMWrap.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.children !== this.props.children || prevProps.overflowedIndicator !== this.props.overflowedIndicator) {
      this.updateNodesCacheAndResize();
    }
  };

  DOMWrap.prototype.componentWillUnmount = function componentWillUnmount() {
    this.debouncedHandleResize.cancel();
    window.removeEventListener('resize', this.debouncedHandleResize);
  };

  // set overflow indicator size
  DOMWrap.prototype.setOverflowedIndicatorSize = function setOverflowedIndicatorSize() {
    var _this2 = this;

    if (this.props.mode !== 'horizontal') {
      return;
    }
    var container = document.body.appendChild(document.createElement('div'));
    container.setAttribute('style', 'position: absolute; top: 0; visibility: hidden');
    _reactDom2['default'].render(this.props.overflowedIndicator, container, function () {
      _this2.overflowedIndicatorWidth = (0, _util.getWidth)(container) + 40;

      _reactDom2['default'].unmountComponentAtNode(container);
      document.body.removeChild(container);
    });
  };

  // memorize rendered menuSize


  DOMWrap.prototype.setChildrenSize = function setChildrenSize() {
    var _this3 = this;

    if (this.props.mode !== 'horizontal') {
      return;
    }
    var container = document.body.appendChild(document.createElement('div'));
    container.setAttribute('style', 'position: absolute; top: 0; visibility: hidden');

    var _props = this.props,
        hiddenClassName = _props.hiddenClassName,
        visible = _props.visible,
        prefixCls = _props.prefixCls,
        overflowedIndicator = _props.overflowedIndicator,
        mode = _props.mode,
        Tag = _props.tag,
        children = _props.children,
        rest = (0, _objectWithoutProperties3['default'])(_props, ['hiddenClassName', 'visible', 'prefixCls', 'overflowedIndicator', 'mode', 'tag', 'children']);


    this.store = (0, _miniStore.create)({
      selectedKeys: [],
      openKeys: [],
      activeKey: {}
    });

    _reactDom2['default'].render(_react2['default'].createElement(
      _miniStore.Provider,
      { store: this.store },
      _react2['default'].createElement(
        Tag,
        rest,
        children
      )
    ), // content

    container, // container

    function () {
      // callback
      var ul = container.childNodes[0];
      var scrollWidth = (0, _util.getScrollWidth)(ul);

      _this3.props.children.forEach(function (c, i) {
        return _this3.childrenSizes[i] = (0, _util.getWidth)(ul.children[i]);
      });

      _this3.originalScrollWidth = scrollWidth;

      _reactDom2['default'].unmountComponentAtNode(container);
      document.body.removeChild(container);
      _this3.handleResize();
    });
  };

  DOMWrap.prototype.updateNodesCacheAndResize = function updateNodesCacheAndResize() {
    this.setOverflowedIndicatorSize();
    this.setChildrenSize();
  };

  // original scroll size of the list


  // copy of overflowed items


  // cache item of the original items (so we can track the size and order)


  DOMWrap.prototype.renderChildren = function renderChildren(children) {
    var _this4 = this;

    // need to take care of overflowed items in horizontal mode
    var lastVisibleIndex = this.state.lastVisibleIndex;

    return _react2['default'].Children.map(children, function (childNode, index) {
      // only process the scenario when overflow actually happens and it's the root menu

      if (_this4.props.mode === 'horizontal') {
        if (lastVisibleIndex !== undefined && _this4.props.className.indexOf(_this4.props.prefixCls + '-root') !== -1) {
          if (index <= lastVisibleIndex) {
            // visible item, just render
            return childNode;
          } else if (index === lastVisibleIndex + 1) {
            // time to use overflow indicator!
            return _this4.getOverflowedSubMenuItem();
          }

          return null;
        }
      }

      return childNode;
    });
  };

  DOMWrap.prototype.render = function render() {
    var _props2 = this.props,
        hiddenClassName = _props2.hiddenClassName,
        visible = _props2.visible,
        prefixCls = _props2.prefixCls,
        overflowedIndicator = _props2.overflowedIndicator,
        mode = _props2.mode,
        Tag = _props2.tag,
        children = _props2.children,
        rest = (0, _objectWithoutProperties3['default'])(_props2, ['hiddenClassName', 'visible', 'prefixCls', 'overflowedIndicator', 'mode', 'tag', 'children']);


    if (!visible) {
      rest.className += ' ' + hiddenClassName;
    }

    return _react2['default'].createElement(
      Tag,
      rest,
      this.renderChildren(this.props.children)
    );
  };

  return DOMWrap;
}(_react2['default'].Component);

DOMWrap.propTypes = {
  tag: _propTypes2['default'].string,
  hiddenClassName: _propTypes2['default'].string,
  visible: _propTypes2['default'].bool
};
DOMWrap.defaultProps = {
  tag: 'div',
  className: ''
};


DOMWrap.propTypes = {
  className: _propTypes2['default'].string,
  children: _propTypes2['default'].node,
  mode: _propTypes2['default'].oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
  prefixCls: _propTypes2['default'].string,
  overflowedIndicator: _propTypes2['default'].node
};

exports['default'] = DOMWrap;
module.exports = exports['default'];