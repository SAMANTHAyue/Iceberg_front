import _extends from 'babel-runtime/helpers/extends';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import debounce from 'lodash/debounce';
import SubMenu from './SubMenu';
import { Provider, create } from 'mini-store';
import { getWidth, getScrollWidth } from './util';

var DOMWrap = function (_React$Component) {
  _inherits(DOMWrap, _React$Component);

  function DOMWrap() {
    var _temp, _this, _ret;

    _classCallCheck(this, DOMWrap);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      lastVisibleIndex: undefined
    }, _this.getOverflowedSubMenuItem = function () {
      var overflowedIndicator = _this.props.overflowedIndicator;
      // put all the overflowed item inside a submenu
      // with a title of overflow indicator ('...')

      var copy = _this.props.children[0];

      var _copy$props = copy.props,
          throwAway = _copy$props.children,
          title = _copy$props.title,
          eventKey = _copy$props.eventKey,
          rest = _objectWithoutProperties(_copy$props, ['children', 'title', 'eventKey']);

      return React.createElement(
        SubMenu,
        _extends({
          title: overflowedIndicator,
          className: _this.props.prefixCls + '-overflowed-submenu'
        }, rest, {
          eventKey: 'overflowed-indicator',
          disabled: false
        }),
        _this.overflowedItems
      );
    }, _this.originalScrollWidth = 0, _this.overflowedItems = [], _this.childrenSizes = [], _this.handleResize = function () {
      if (_this.props.mode !== 'horizontal') {
        return;
      }

      var ul = ReactDOM.findDOMNode(_this);
      var width = getWidth(ul);

      _this.overflowedItems = [];
      var currentSumWidth = 0;
      var children = _this.props.children;

      // index for last visible child in horizontal mode
      var lastVisibleIndex = undefined;

      if (_this.originalScrollWidth > width) {
        lastVisibleIndex = -1;

        _this.childrenSizes.forEach(function (liWidth) {
          currentSumWidth += liWidth;
          if (currentSumWidth + _this.overflowedIndicatorWidth <= width) {
            lastVisibleIndex++;
          }
        });

        children.slice(lastVisibleIndex + 1).forEach(function (c) {
          // children[index].key will become '.$key' in clone by default,
          // we have to overwrite with the correct key explicitly
          _this.overflowedItems.push(React.cloneElement(c, { key: c.props.eventKey, mode: 'vertical-left' }));
        });
      }

      _this.setState({ lastVisibleIndex: lastVisibleIndex });
    }, _this.debouncedHandleResize = debounce(_this.handleResize, 150), _temp), _possibleConstructorReturn(_this, _ret);
  }

  DOMWrap.prototype.componentDidMount = function componentDidMount() {
    this.updateNodesCacheAndResize();
    window.addEventListener('resize', this.debouncedHandleResize, { passive: true });
  };

  DOMWrap.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.children !== this.props.children || prevProps.overflowedIndicator !== this.props.overflowedIndicator) {
      this.updateNodesCacheAndResize();
    }
  };

  DOMWrap.prototype.componentWillUnmount = function componentWillUnmount() {
    this.debouncedHandleResize.cancel();
    window.removeEventListener('resize', this.debouncedHandleResize);
  };

  // set overflow indicator size
  DOMWrap.prototype.setOverflowedIndicatorSize = function setOverflowedIndicatorSize() {
    var _this2 = this;

    if (this.props.mode !== 'horizontal') {
      return;
    }
    var container = document.body.appendChild(document.createElement('div'));
    container.setAttribute('style', 'position: absolute; top: 0; visibility: hidden');
    ReactDOM.render(this.props.overflowedIndicator, container, function () {
      _this2.overflowedIndicatorWidth = getWidth(container) + 40;

      ReactDOM.unmountComponentAtNode(container);
      document.body.removeChild(container);
    });
  };

  // memorize rendered menuSize


  DOMWrap.prototype.setChildrenSize = function setChildrenSize() {
    var _this3 = this;

    if (this.props.mode !== 'horizontal') {
      return;
    }
    var container = document.body.appendChild(document.createElement('div'));
    container.setAttribute('style', 'position: absolute; top: 0; visibility: hidden');

    var _props = this.props,
        hiddenClassName = _props.hiddenClassName,
        visible = _props.visible,
        prefixCls = _props.prefixCls,
        overflowedIndicator = _props.overflowedIndicator,
        mode = _props.mode,
        Tag = _props.tag,
        children = _props.children,
        rest = _objectWithoutProperties(_props, ['hiddenClassName', 'visible', 'prefixCls', 'overflowedIndicator', 'mode', 'tag', 'children']);

    this.store = create({
      selectedKeys: [],
      openKeys: [],
      activeKey: {}
    });

    ReactDOM.render(React.createElement(
      Provider,
      { store: this.store },
      React.createElement(
        Tag,
        rest,
        children
      )
    ), // content

    container, // container

    function () {
      // callback
      var ul = container.childNodes[0];
      var scrollWidth = getScrollWidth(ul);

      _this3.props.children.forEach(function (c, i) {
        return _this3.childrenSizes[i] = getWidth(ul.children[i]);
      });

      _this3.originalScrollWidth = scrollWidth;

      ReactDOM.unmountComponentAtNode(container);
      document.body.removeChild(container);
      _this3.handleResize();
    });
  };

  DOMWrap.prototype.updateNodesCacheAndResize = function updateNodesCacheAndResize() {
    this.setOverflowedIndicatorSize();
    this.setChildrenSize();
  };

  // original scroll size of the list


  // copy of overflowed items


  // cache item of the original items (so we can track the size and order)


  DOMWrap.prototype.renderChildren = function renderChildren(children) {
    var _this4 = this;

    // need to take care of overflowed items in horizontal mode
    var lastVisibleIndex = this.state.lastVisibleIndex;

    return React.Children.map(children, function (childNode, index) {
      // only process the scenario when overflow actually happens and it's the root menu

      if (_this4.props.mode === 'horizontal') {
        if (lastVisibleIndex !== undefined && _this4.props.className.indexOf(_this4.props.prefixCls + '-root') !== -1) {
          if (index <= lastVisibleIndex) {
            // visible item, just render
            return childNode;
          } else if (index === lastVisibleIndex + 1) {
            // time to use overflow indicator!
            return _this4.getOverflowedSubMenuItem();
          }

          return null;
        }
      }

      return childNode;
    });
  };

  DOMWrap.prototype.render = function render() {
    var _props2 = this.props,
        hiddenClassName = _props2.hiddenClassName,
        visible = _props2.visible,
        prefixCls = _props2.prefixCls,
        overflowedIndicator = _props2.overflowedIndicator,
        mode = _props2.mode,
        Tag = _props2.tag,
        children = _props2.children,
        rest = _objectWithoutProperties(_props2, ['hiddenClassName', 'visible', 'prefixCls', 'overflowedIndicator', 'mode', 'tag', 'children']);

    if (!visible) {
      rest.className += ' ' + hiddenClassName;
    }

    return React.createElement(
      Tag,
      rest,
      this.renderChildren(this.props.children)
    );
  };

  return DOMWrap;
}(React.Component);

DOMWrap.propTypes = {
  tag: PropTypes.string,
  hiddenClassName: PropTypes.string,
  visible: PropTypes.bool
};
DOMWrap.defaultProps = {
  tag: 'div',
  className: ''
};


DOMWrap.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  mode: PropTypes.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
  prefixCls: PropTypes.string,
  overflowedIndicator: PropTypes.node
};

export default DOMWrap;